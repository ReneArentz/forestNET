namespace ForestNET.Lib.Net.Sock.Task.Recv
{
    /// <summary>
    /// Handshake task class to receive a short triple handshake over a socket instance. Only TCP supported.
    /// Handshake consists of two bytes:
    /// First byte is determined by a constant within ForestNET.Lib.Net.Sock.Task.Task class. This will always be checked.
    /// Second byte is a random value between 0 and 255, generated by handshake sender.
    /// After these two bytes has been sent, the receiver will increase the second byte by 1 and will send both bytes back.
    /// Sender will check if increased second byte has correct value and also increase the second byte, sending it again to receiver.
    /// Receiver will check the second byte one last time. If the correct value is approved, triple handshake over TCP was successful.
    /// </summary>
    public class HandshakeReceive : ForestNET.Lib.Net.Sock.Task.Task
    {
        /// <summary>
        /// interface delegate definition which can be instanced outside of ForestNET.Lib.Net.Sock.Task.Recv.HandshakeReceive<T> class to execute code after triple handshake
        /// </summary>
        public delegate void AdditionalExecution();

        private bool b_endless = false;
        private int i_taskIntervalMilliseconds = 0;
        private AdditionalExecution? del_additionalExecution = null;

        /// <summary>
        /// true - do not stop socket/task at the end of the triple handshake
        /// </summary>
        public bool Endless
        {
            get
            {
                return this.b_endless;
            }
            set
            {
                this.b_endless = value;
            }
        }

        public int TaskIntervalMilliseconds
        {
            get
            {
                return this.i_taskIntervalMilliseconds;
            }
            set
            {
                if (value < 1)
                {
                    throw new ArgumentException("Task timeout must be at least '1' millisecond, but was set to '" + value + "' millisecond(s)");
                }

                this.i_taskIntervalMilliseconds = value;
            }
        }

        public AdditionalExecution? AdditionalExecutionDelegate
        {
            get
            {
                return this.del_additionalExecution;
            }
            set
            {
                if ((this.Type == ForestNET.Lib.Net.Sock.Type.TCP_SERVER) || (this.Type == ForestNET.Lib.Net.Sock.Type.TCP_CLIENT) || (this.Type == ForestNET.Lib.Net.Sock.Type.TCP_TLS_SERVER) || (this.Type == ForestNET.Lib.Net.Sock.Type.TCP_TLS_CLIENT))
                {
                    this.del_additionalExecution = value;
                }
            }
        }

        /// <summary>
        /// Parameterless constructor for TCP RunServer method
        /// </summary>
        public HandshakeReceive() : base(ForestNET.Lib.Net.Sock.Type.TCP_TLS_SERVER)
        {

        }

        /// <summary>
        /// Creating handshake task instance with all it's parameters and settings
        /// </summary>
        /// <param name="p_e_type">specifies socket type of socket task</param>
        public HandshakeReceive(ForestNET.Lib.Net.Sock.Type p_e_type) : base(p_e_type)
        {

        }

        /// <summary>
        /// method to clone this socket task with another socket task instance
        /// </summary>
        /// <param name="p_o_sourceTask">another socket task instance as source for all it's parameters and settings</param>
        public override void CloneFromOtherTask(ForestNET.Lib.Net.Sock.Task.Task p_o_sourceTask)
        {
            this.CloneBasicProperties(p_o_sourceTask);

            try { this.b_endless = ((ForestNET.Lib.Net.Sock.Task.Recv.HandshakeReceive)p_o_sourceTask).Endless; } catch (Exception) { /* NOP */ }
            try { this.i_taskIntervalMilliseconds = ((ForestNET.Lib.Net.Sock.Task.Recv.HandshakeReceive)p_o_sourceTask).TaskIntervalMilliseconds; } catch (Exception) { /* NOP */ }
            try { this.del_additionalExecution = ((ForestNET.Lib.Net.Sock.Task.Recv.HandshakeReceive)p_o_sourceTask).AdditionalExecutionDelegate; } catch (Exception) { /* NOP */ }
        }

        /// <summary>
        /// runTask method of receiving a handshake.
        /// </summary>
        /// <exception cref="Exception">any exception of implementation that could happen will be caught by abstract Task class, see details in protocol methods in ForestNET.Lib.Net.Sock.Task.Recv.HandshakeReceive</exception>
        public override async System.Threading.Tasks.Task RunTask()
        {
            do
            {
                await this.HandshakeTask();

                /* set stop flag to stop task/socket thread */
                this.Stop = this.CancellationToken?.IsCancellationRequested ?? true;

                /* if task/socket is not canceled and task timeout is set */
                if ((!(this.CancellationToken?.IsCancellationRequested ?? true)) && (this.TaskIntervalMilliseconds > 0))
                {
                    /* wait task timeout */
                    Thread.Sleep(this.TaskIntervalMilliseconds);
                }
            } while ((this.Endless) && (!(this.CancellationToken?.IsCancellationRequested ?? true)));
        }

        /// <summary>
        /// method containing logic to receive a handshake.
        /// </summary>
        /// <exception cref="Exception">any exception of implementation that could happen will be caught by abstract Task class, see details in protocol methods in ForestNET.Lib.Net.Sock.Task.Recv.HandshakeReceive</exception>
        private async System.Threading.Tasks.Task HandshakeTask()
        {
            /* only TCP supported */
            if ((this.Type == ForestNET.Lib.Net.Sock.Type.TCP_CLIENT) || (this.Type == ForestNET.Lib.Net.Sock.Type.TCP_SERVER) || (this.Type == ForestNET.Lib.Net.Sock.Type.TCP_TLS_CLIENT) || (this.Type == ForestNET.Lib.Net.Sock.Type.TCP_TLS_SERVER))
            {
                /* help variables and byte array for receiving handshake bytes */
                byte[]? a_handshakeBytes;
                int i_maxAttempts = 40;
                int i_attempts = 1;

                do
                {
                    /* receiving both handshake bytes, first byte is a constant and the second is a random number between 0 and 255 determined by other communication side */
                    a_handshakeBytes = await this.ReceiveBytes(2, 2);

                    if ((a_handshakeBytes == null) || (a_handshakeBytes.Length == 0))
                    {
                        throw new InvalidOperationException("Handshake failed. Protocol for receiving handshake failed completely or was not intended (check availability call over TCP)");
                    }

                    ForestNET.Lib.Global.ILogFiner("Received handshake: '" + ForestNET.Lib.Helper.PrintByteArray(a_handshakeBytes, false) + "'");

                    /* first byte must match constant within Task class */
                    if (a_handshakeBytes[0] != ForestNET.Lib.Net.Sock.Task.Task.BY_ACK_BYTE)
                    {
                        ForestNET.Lib.Global.ILogWarning("Invalid first byte of handshake[" + ForestNET.Lib.Helper.PrintByteArray(new byte[] { a_handshakeBytes[0] }, false).Trim() + "], must be [" + ForestNET.Lib.Helper.PrintByteArray(new byte[] { ForestNET.Lib.Net.Sock.Task.Task.BY_ACK_BYTE }, false).Trim() + "]; retry after 25 milliseconds");

                        /* wait 25 milliseconds to receive handshake bytes again */
                        await System.Threading.Tasks.Task.Delay(25);

                        if (i_attempts >= i_maxAttempts)
                        { /* all attempts failed, so protocol for receiving handshake failed completely */
                            throw new InvalidOperationException("Handshake failed, receiver first step, after " + i_attempts + " attempts");
                        }
                    }
                } while (a_handshakeBytes[0] != ForestNET.Lib.Net.Sock.Task.Task.BY_ACK_BYTE); /* loop ended if first byte match constant */

                /* ------------------------------------------------------ */

                /* increase received random number in second byte, this will be expected by other communication side */
                a_handshakeBytes[1]++;
                /* remember increased value of second byte for later use */
                byte by_remember = a_handshakeBytes[1];

                /* help variables */
                bool b_retry = true;
                i_maxAttempts = 40;
                i_attempts = 1;

                do
                {
                    try
                    {
                        ForestNET.Lib.Global.ILogFiner("Send handshake: '" + ForestNET.Lib.Helper.PrintByteArray(a_handshakeBytes, false) + "'");

                        /* send both handshake bytes with modified second byte */
                        await this.SendBytes(a_handshakeBytes, a_handshakeBytes.Length);
                        b_retry = false;
                    }
                    catch (Exception o_exc)
                    {
                        ForestNET.Lib.Global.ILogWarning("Could not send handshake[" + ForestNET.Lib.Helper.PrintByteArray(a_handshakeBytes, false).Trim() + "]; retry after 25 milliseconds");

                        /* wait 25 milliseconds to send handshake bytes again */
                        await System.Threading.Tasks.Task.Delay(25);

                        if (i_attempts >= i_maxAttempts)
                        { /* all attempts failed, so protocol for receiving handshake failed completely */
                            throw new Exception("Handshake failed, receiver second step, after " + i_attempts + " attempts; " + o_exc);
                        }
                    }
                } while (b_retry); /* loop ended if handshake bytes could be sent without any exception */

                /* ------------------------------------------------------ */

                /* help variables and reset byte array for receiving handshake bytes */
                i_maxAttempts = 40;
                i_attempts = 1;

                do
                {
                    /* receiving both handshake bytes, first byte is a constant and the second byte have been increased of other communication side */
                    a_handshakeBytes = await this.ReceiveBytes(2, 2);

                    ForestNET.Lib.Global.ILogFine("Received handshake: '" + ForestNET.Lib.Helper.PrintByteArray(a_handshakeBytes, false) + "'");

                    /* handshake bytes must no be null */
                    if (a_handshakeBytes == null)
                    {
                        ForestNET.Lib.Global.ILogWarning("Handshake bytes are [null], must be [" + ForestNET.Lib.Helper.PrintByteArray(new byte[] { ForestNET.Lib.Net.Sock.Task.Task.BY_ACK_BYTE }, false).Trim() + "]; retry after 25 milliseconds");

                        /* wait 25 milliseconds to receive handshake bytes again */
                        await System.Threading.Tasks.Task.Delay(25);

                        if (i_attempts >= i_maxAttempts)
                        { /* all attempts failed, so protocol for receiving handshake failed completely */
                            throw new InvalidOperationException("Handshake failed, receiver first step, after " + i_attempts + " attempts");
                        }
                    }
                    else if (a_handshakeBytes[0] != ForestNET.Lib.Net.Sock.Task.Task.BY_ACK_BYTE) /* first byte must match constant within Task class */
                    {
                        ForestNET.Lib.Global.ILogWarning("Invalid first byte of handshake[" + ForestNET.Lib.Helper.PrintByteArray(new byte[] { a_handshakeBytes[0] }, false).Trim() + "], must be [" + ForestNET.Lib.Helper.PrintByteArray(new byte[] { ForestNET.Lib.Net.Sock.Task.Task.BY_ACK_BYTE }, false).Trim() + "]; retry after 25 milliseconds");

                        /* wait 25 milliseconds to receive handshake bytes again */
                        await System.Threading.Tasks.Task.Delay(25);

                        if (i_attempts >= i_maxAttempts)
                        { /* all attempts failed, so protocol for receiving handshake failed completely */
                            throw new InvalidOperationException("Handshake failed, receiver first step, after " + i_attempts + " attempts");
                        }
                    }
                    else if (a_handshakeBytes[1] != (by_remember + 0x01))
                    { /* second byte must match remembered increased value of second byte + 1 */
                        ForestNET.Lib.Global.ILogWarning("Invalid second byte of handshake[" + ForestNET.Lib.Helper.PrintByteArray(new byte[] { a_handshakeBytes[1] }, false).Trim() + "], should be [" + ForestNET.Lib.Helper.PrintByteArray(new byte[] { (byte)(by_remember + 1) }, false).Trim() + "]; retry after 25 milliseconds");

                        /* wait 25 milliseconds to receive handshake bytes again */
                        await System.Threading.Tasks.Task.Delay(25);

                        if (i_attempts >= i_maxAttempts)
                        { /* all attempts failed, so protocol for receiving handshake failed completely */
                            throw new Exception("Handshake failed, receiver third step, after " + i_attempts + " attempts");
                        }
                    }
                } while ((a_handshakeBytes == null) || ((a_handshakeBytes[0] != ForestNET.Lib.Net.Sock.Task.Task.BY_ACK_BYTE) && (a_handshakeBytes[1] != (by_remember + 0x01)))); /* see three if conditions above */

                /* ------------------------------------------------------ */

                ForestNET.Lib.Global.ILog("TCP Triple Handshake finished successfully");

                /* execute additional code with delegate if it is set */
                this.AdditionalExecutionDelegate?.Invoke();
            }
            else if ((this.Type == ForestNET.Lib.Net.Sock.Type.UDP_CLIENT) || (this.Type == ForestNET.Lib.Net.Sock.Type.UDP_SERVER))
            {
                throw new InvalidOperationException("Not implemented for UDP protocol");
            }
            else
            {
                throw new InvalidOperationException("Not implemented");
            }
        }
    }
}